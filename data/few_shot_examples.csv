question,content
Does the volume of 997808 of the Article1 M000463G01 exceed the capacity of the shift 3 multiply by 2?,"WITH params AS (
    SELECT 
        ""Cadence"",
        ""Emp.Moule"",
        ""Emp.Pce"",
        ""TRS""
    FROM charge_capa3
    WHERE ""Article1"" = 'M000463G01'
    LIMIT 1
),
tps_calculations AS (
    SELECT 
        997808 AS target_volume,
        target_volume / (p.""Cadence"" * (p.""Emp.Moule"" / NULLIF(p.""Emp.Pce"", 0))) AS tps_machine_net,
        (target_volume / (p.""Cadence"" * (p.""Emp.Moule"" / NULLIF(p.""Emp.Pce"", 0)))) 
        * ((1 - p.""TRS"") / NULLIF(p.""TRS"", 0)) AS tps_pertes
    FROM params p
),
total_tps AS (
    SELECT 
        tps_machine_net + tps_pertes AS total_required_tps
    FROM tps_calculations
),
shift3_capacity AS (
    SELECT SUM(capacity / 4) * 2 AS doubled_annual_capacity
    FROM capacity
    WHERE shift_number = 3
)
SELECT 
    total_required_tps,
    doubled_annual_capacity,
    CASE 
        WHEN total_required_tps > doubled_annual_capacity THEN 'Yes' 
        ELSE 'No' 
    END AS capacity_exceeded
FROM total_tps, shift3_capacity;"
can you give me if the article M000463G01 and M000671G01 has 997808 in there volume exceed the shift capacity of the shift 3,"WITH annual_capacity AS (
    SELECT SUM(capacity / 4) AS total_annual_capacity
    FROM capacity
    WHERE shift_number = 3
),
articles AS (
    SELECT 'M000463G01' AS article
    UNION ALL
    SELECT 'M000671G01'
),
params AS (
    SELECT 
        a.article,
        c.""Cadence"",
        c.""Emp.Moule"",
        c.""Emp.Pce"",
        c.""TRS""
    FROM articles a
    LEFT JOIN (
        SELECT 
            ""Article1"",
            ""Cadence"",
            ""Emp.Moule"",
            ""Emp.Pce"",
            ""TRS"",
            ROW_NUMBER() OVER (PARTITION BY ""Article1"" ORDER BY ""Article1"") as rn
        FROM charge_capa3
        WHERE ""Article1"" IN ('M000463G01', 'M000671G01')
    ) c ON a.article = c.""Article1"" AND c.rn = 1
),
tps_calculations AS (
    SELECT 
        article,
        997808 AS target_volume,
        target_volume / (p.""Cadence"" * (p.""Emp.Moule"" / NULLIF(p.""Emp.Pce"", 0))) AS tps_machine_net,
        (target_volume / (p.""Cadence"" * (p.""Emp.Moule"" / NULLIF(p.""Emp.Pce"", 0)))) 
        * ((1 - p.""TRS"") / NULLIF(p.""TRS"", 0)) AS tps_pertes
    FROM params p
),
total_tps AS (
    SELECT 
        article,
        tps_machine_net + tps_pertes AS total_required_tps
    FROM tps_calculations
)
SELECT 
    t.article,
    t.total_required_tps,
    ac.total_annual_capacity,
    CASE 
        WHEN t.total_required_tps <= ac.total_annual_capacity THEN 'No' 
        ELSE 'Yes' 
    END AS capacity_exceeded
FROM total_tps t
CROSS JOIN annual_capacity ac;"
"can you show me the Composant M000634D01 and M000634G01 with there Art.intra-process, Opé,  Description, Pos.trav","SELECT 
    ""Composant"",
    ""Art.intra-process"",
    ""Opé."",
    ""Description"",
    ""Pos.trav""
FROM charge_capa3
WHERE ""Art.intra-process"" IN ('M000634D01', 'M000634G01');"
can you show me all machine that exceted the capacity of the shift 3,"WITH shift3_total AS (
   SELECT
     SUM(capacity::numeric / 4) AS base_capacity
   FROM capacity
   WHERE shift_number = 3
),
machines_data AS (
   SELECT
     ""Pos.trav""              AS machine,
     max(""Nbre de PDC"")       AS total_pdc,
     SUM(""TPS MACHINE TT"")    AS total_machine_time
   FROM charge_capa3
   WHERE ""TPS MACHINE NET"" IS NOT NULL
     AND ""Is_Masque"" = FALSE
   GROUP BY ""Pos.trav""
),
adjusted_capacity AS (
   SELECT
     m.machine,
     s.base_capacity * GREATEST(m.total_pdc, 1) AS annual_capacity,
     m.total_machine_time
   FROM machines_data AS m
   CROSS JOIN shift3_total AS s
)
SELECT
  a.machine,
  a.annual_capacity,
  a.total_machine_time,
  CASE
    WHEN a.total_machine_time > a.annual_capacity THEN 'Exceeded'
    ELSE 'Sufficient'
  END AS capacity_status
FROM adjusted_capacity AS a
WHERE a.total_machine_time > a.annual_capacity;"
can you give if the capacity anuual of the ZAP 'ZAP Goujon' pass the capacity of the shift 3,"WITH nbrpost AS (
    SELECT DISTINCT 
        ""Pos.trav"",
        ""Nbre de PDC""
    FROM charge_capa3
    WHERE
        ""TPS MACHINE NET"" IS NOT NULL
        AND ""Is_Masque"" = FALSE
        AND ""ZAP"" = 'ZAP Goujon'
),
total_pdc AS (
    SELECT SUM(""Nbre de PDC"") AS sum_pdc
    FROM nbrpost
),
base_capacity AS (
    SELECT SUM(c.capacity / 4) AS base_capacity
    FROM capacity c
    WHERE c.shift_number = 3
),
annual_shift_capacity AS (
    SELECT 
        bc.base_capacity * tp.sum_pdc AS total_annual_capacity
    FROM base_capacity bc
    CROSS JOIN total_pdc tp
),
machine_requirements AS (
    SELECT 
        SUM(""TPS MACHINE TT"" + ""TPS PERTES"") AS total_machine_time
    FROM charge_capa3
    WHERE 
        ""ZAP"" = 'ZAP Goujon'
        AND ""TPS MACHINE NET"" IS NOT NULL
        AND ""Is_Masque"" = FALSE
)
SELECT 
    total_annual_capacity,
    COALESCE(total_machine_time, 0) AS total_machine_time,
    CASE 
        WHEN total_annual_capacity >= COALESCE(total_machine_time, 0) 
        THEN 'Capacity sufficient' 
        ELSE 'Capacity exceeded' 
    END AS capacity_status
FROM annual_shift_capacity, machine_requirements;"
can you show me idf we exceted the capacity of the ZAP GT compare to shift 3,"WITH nbrpost AS (
    -- Grab each machine’s PDC count
    SELECT DISTINCT 
        ""Pos.trav"",
        ""Nbre de PDC""
    FROM charge_capa3
    WHERE
        ""TPS MACHINE NET"" IS NOT NULL
        AND ""Is_Masque"" = FALSE
        AND ""ZAP"" = 'ZAP GT'
),
total_pdc AS (
    -- Sum up all the PDCs once
    SELECT SUM(""Nbre de PDC"") AS sum_pdc
    FROM nbrpost
),
base_capacity AS (
    -- Just sum up the base capacity (divide by 4 as needed)
    SELECT SUM(c.capacity / 4) AS base_capacity
    FROM capacity c
    WHERE c.shift_number = 3
),
annual_shift_capacity AS (
    -- Multiply summed capacity by sum_pdc
    SELECT 
        bc.base_capacity * tp.sum_pdc AS total_annual_capacity
    FROM base_capacity bc
    CROSS JOIN total_pdc tp
),
machine_requirements AS (
    -- Sum total required machine time
    SELECT 
	SUM(""TPS MACHINE NET"") as TMN,
	SUM(""TPS PERTES"") as TP,
    SUM(""TPS MACHINE NET"") + SUM(""TPS PERTES"") AS total_machine_time
    FROM charge_capa3
    WHERE 
	""TPS MACHINE NET"" IS NOT NULL
    AND ""Is_Masque"" = FALSE
	AND ""ZAP"" = 'ZAP GT'
)
-- Final select with non-reserved aliases
SELECT 
    ann_cap.total_annual_capacity,
    COALESCE(mr.total_machine_time, 0) AS total_machine_time,
    CASE 
        WHEN ann_cap.total_annual_capacity >= COALESCE(mr.total_machine_time, 0) 
        THEN 'Capacity sufficient' 
        ELSE 'Capacity exceeded' 
    END AS capacity_status
FROM annual_shift_capacity AS ann_cap
CROSS JOIN machine_requirements AS mr;
"
can you show if the ZAP CELLULE SR exceeted the capacity of the shift 3,"WITH nbrpost AS (
    -- Grab each machine’s PDC count
    SELECT DISTINCT 
        ""Pos.trav"",
        ""Nbre de PDC""
    FROM charge_capa3
    WHERE
        C IS NOT NULL
        AND ""Is_Masque"" = FALSE
        AND ""ZAP"" = 'ZAP CELLULE SR'
),
total_pdc AS (
    -- Sum up all the PDCs once
    SELECT SUM(""Nbre de PDC"") AS sum_pdc
    FROM nbrpost
),
base_capacity AS (
    -- Just sum up the base capacity (divide by 4 as needed)
    SELECT SUM(c.capacity / 4) AS base_capacity
    FROM capacity c
    WHERE c.shift_number = 3
),
annual_shift_capacity AS (
    -- Multiply summed capacity by sum_pdc
    SELECT 
        bc.base_capacity * tp.sum_pdc AS total_annual_capacity
    FROM base_capacity bc
    CROSS JOIN total_pdc tp
),
machine_requirements AS (
    -- Sum total required machine time
    SELECT 
	SUM(""TPS MACHINE NET"") as TMN,
	SUM(""TPS PERTES"") as TP,
    SUM(""TPS MACHINE NET"") + SUM(""TPS PERTES"") AS total_machine_time
    FROM charge_capa3
    WHERE 
	""TPS MACHINE NET"" IS NOT NULL
    AND ""Is_Masque"" = FALSE
	AND ""ZAP"" = 'ZAP CELLULE SR'
)
-- Final select with non-reserved aliases
SELECT 
	mr.TMN as TMN,
	mr.TP as TP,
    ann_cap.total_annual_capacity,
    COALESCE(mr.total_machine_time, 0) AS total_machine_time,
    CASE 
        WHEN ann_cap.total_annual_capacity >= COALESCE(mr.total_machine_time, 0) 
        THEN 'Capacity sufficient' 
        ELSE 'Capacity exceeded' 
    END AS capacity_status
FROM annual_shift_capacity AS ann_cap
CROSS JOIN machine_requirements AS mr;
"
is the capacity of the machine PRP_AC exceted the shift 3 compart it annualy,"WITH nbrpost AS (
    -- Grab each machine’s PDC count
    SELECT DISTINCT 
        ""Pos.trav"",
        ""Nbre de PDC""
    FROM charge_capa3
    WHERE
        ""TPS MACHINE NET"" IS NOT NULL
        AND ""Is_Masque"" = FALSE
        AND ""Pos.trav"" = 'PRP_AC'
),
total_pdc AS (
    -- Sum up all the PDCs once
    SELECT SUM(""Nbre de PDC"") AS sum_pdc
    FROM nbrpost
),
base_capacity AS (
    -- Just sum up the base capacity (divide by 4 as needed)
    SELECT SUM(c.capacity / 4) AS base_capacity
    FROM capacity c
    WHERE c.shift_number = 3
),
annual_shift_capacity AS (
    -- Multiply summed capacity by sum_pdc
    SELECT 
        bc.base_capacity * tp.sum_pdc AS total_annual_capacity
    FROM base_capacity bc
    CROSS JOIN total_pdc tp
),
machine_requirements AS (
    -- Sum total required machine time
    SELECT 
        SUM(""TPS MACHINE TT"") AS total_machine_time
    FROM charge_capa3
    WHERE 
	""TPS MACHINE NET"" IS NOT NULL
    AND ""Is_Masque"" = FALSE
	AND ""Pos.trav"" = 'PRP_AC'
)
-- Final select with non-reserved aliases
SELECT 
    ann_cap.total_annual_capacity,
    COALESCE(mr.total_machine_time, 0) AS total_machine_time,
    CASE 
        WHEN ann_cap.total_annual_capacity >= COALESCE(mr.total_machine_time, 0) 
        THEN 'Capacity sufficient' 
        ELSE 'Capacity exceeded' 
    END AS capacity_status
FROM annual_shift_capacity AS ann_cap
CROSS JOIN machine_requirements AS mr;
"
is the capacity of the machine ILT_SR01 exceted the shift 3 compart it annualy,"WITH annual_shift_capacity AS (
    SELECT 
        SUM(capacity / 4) AS total_annual_capacity
    FROM shift_capacity
    WHERE shift_number = 3
),
machine_requirements AS (
    SELECT 
        SUM(""TPS MACHINE TT"") AS total_machine_time
    FROM charge_capa3
    WHERE ""Pos.trav"" = 'ILT_SR01'
)
SELECT 
    total_annual_capacity,
    COALESCE(total_machine_time, 0) AS total_machine_time,
    CASE 
        WHEN total_annual_capacity >= COALESCE(total_machine_time, 0) 
        THEN 'Capacity sufficient' 
        ELSE 'Capacity exceeded' 
    END AS capacity_status
FROM annual_shift_capacity, machine_requirements;"
can you show me for the zap SR what how exceted the capactity of the 3 shifts try to calaculated annualy,"WITH shift_capacity_sr AS (
    SELECT 
        SUM(capacity / 4) AS total_annual_capacity_sr
    FROM capacity 
	where
		shift_number IN (3)
),
machine_pa0300_requirements AS (
    SELECT 
        SUM(""TPS MACHINE TT"") AS total_machine_time_pa0300
    FROM charge_capa3
    WHERE ""Pos.trav"" = 'PA0300'
)
SELECT 
    total_annual_capacity_sr,
    total_machine_time_pa0300,
    CASE 
        WHEN total_annual_capacity_sr >= total_machine_time_pa0300 
        THEN 'Sufficient' 
        ELSE 'Insufficient' 
    END AS capacity_status
FROM shift_capacity_sr, machine_pa0300_requirements;"
can you show me all development program,"SELECT DISTINCT ""Numéro d'article"" AS development_program
FROM manufacturing_data;"
"are we able to produce 974647 parts in a year for article M000463G01, use the following formulas: TPS MACHINE NET = Volume / (Cadence*(emp moul/emp piece)) TPS PERTES = TPS MACHINE NET*((1-TRS)/(TRS)) then sum the two of them, and compare it with the annual capacity(sum of (capacity divided by 4)) of shift_number 3","WITH parameters AS (
    SELECT 
        ""Cadence"",
        ""Emp.Moule"",
        ""Emp.Pce"",
        ""TRS""
    FROM charge_capa3
    WHERE ""Article1"" = 'M000463G01'
),
tps_calculations AS (
    SELECT 
        974647 AS target_volume,
        target_volume / (p.""Cadence"" * (p.""Emp.Moule"" / NULLIF(p.""Emp.Pce"", 0))) AS tps_machine_net,
        (target_volume / (p.""Cadence"" * (p.""Emp.Moule"" / NULLIF(p.""Emp.Pce"", 0)))) 
        * ((1 - p.""TRS"") / NULLIF(p.""TRS"", 0)) AS tps_pertes
    FROM parameters p
),
total_tps AS (
    SELECT 
        tps_machine_net + tps_pertes AS total_required_tps
    FROM tps_calculations
),
annual_capacity AS (
    SELECT SUM(capacity / 4) AS total_annual_capacity
    FROM capacity
    WHERE shift_number = 3
)
SELECT 
    total_required_tps,
    total_annual_capacity,
    CASE 
        WHEN total_required_tps <= total_annual_capacity THEN 'Yes' 
        ELSE 'No' 
    END AS production_possible
FROM total_tps, annual_capacity;"
"How many machines are needed to produce 50,000 pieces per year if the production rate is based on the average weekly production ?","WITH weekly_production AS (
    SELECT 
        COUNT(*) AS units_produced
    FROM table_states 
    WHERE state = '35' 
    GROUP BY EXTRACT(WEEK FROM start_time)
),
average_weekly_production AS (
    SELECT AVG(units_produced) AS avg_weekly_production
    FROM weekly_production
),
machines_needed AS (
    SELECT 
        CEIL(50000 / (avg_weekly_production * 52)) AS machines_needed,
        CEIL(50000 / ((avg_weekly_production * 1.10) * 52)) AS machines_needed_increased
    FROM average_weekly_production
)
SELECT * FROM machines_needed;"
"How many machines are needed to produce 50,000 pieces per year if the production rate is based on the average weekly production ?","WITH weekly_production AS (
    SELECT 
        COUNT(*) AS units_produced
    FROM table_states 
    WHERE state = '35' 
    GROUP BY EXTRACT(WEEK FROM start_time)
),
average_weekly_production AS (
    SELECT AVG(units_produced) AS avg_weekly_production
    FROM weekly_production
)
SELECT 
    CEIL(50000 / (avg_weekly_production * 52)) AS machines_needed
FROM average_weekly_production;"
count the production of each week,"WITH weekly_production AS (
    SELECT 
        EXTRACT(WEEK FROM start_time) AS week_number,
        COUNT(*) AS production_count
    FROM table_states
    WHERE state = '35'
    GROUP BY EXTRACT(WEEK FROM start_time)
),
average_weekly_production AS (
    SELECT AVG(production_count) AS avg_weekly_production
    FROM weekly_production
)
SELECT 
    DISTINCT CEIL(50000 / (avg_weekly_production * 52)) AS machines_needed
FROM weekly_production, average_weekly_production;"
count the production of each week,"WITH weekly_production AS (
    SELECT 
        EXTRACT(WEEK FROM start_time) AS week_number,
        COUNT(*) AS production_count
    FROM table_states
    WHERE state = '35'
    GROUP BY EXTRACT(WEEK FROM start_time)
)
SELECT week_number, production_count
FROM weekly_production
ORDER BY week_number;"
"combien de machine est neccessaire pour produise 50000 pieces par ans, prend le W11 comme un reference pour les total unite produise","WITH weekly_production AS (
    SELECT 
        COUNT(*) AS units_produced
    FROM table_states 
    WHERE state = '35' 
      AND table_name = 'TAB10'
      AND EXTRACT(WEEK FROM start_time) = 11
)
SELECT 
    CEIL(50000 / ((units_produced * 52) / 1)) AS machines_needed
FROM weekly_production;"
"pour un charge capacitaire de 10000 pieces par ans, combien de machine est neccessaire","WITH february_production AS (
    SELECT 
        COUNT(*) AS units_produced
    FROM table_states 
    WHERE state = '35' 
      AND table_name = 'TAB10'
      AND EXTRACT(MONTH FROM start_time) = 2
)
SELECT 
    CEIL(10000 / ((units_produced*12) / 1)) AS machines_needed
FROM february_production;"
calculer trs utilisant ce ficher de qualite,"WITH filtered_data AS (
    SELECT 
        start_time::date AS day,
        start_time,
        end_time,
        state_description,
        EXTRACT(EPOCH FROM (end_time - start_time)) AS duration_seconds
    FROM tab10
    WHERE state_description IN ('Loading', 'Processing', 'Waiting', 'Welding', 'Unloading')
      AND (start_time::timestamp)::time BETWEEN '08:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
),
daily_medians AS (
    SELECT 
        day,
        state_description,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration_seconds) AS median_duration_seconds
    FROM filtered_data
    GROUP BY day, state_description
),
downtime_calculation AS (
    SELECT 
        fd.day,
        SUM(CASE 
                WHEN fd.duration_seconds > dm.median_duration_seconds 
                THEN fd.duration_seconds - dm.median_duration_seconds 
                ELSE 0 
            END) - 60600 AS total_downtime
    FROM filtered_data fd
    JOIN daily_medians dm 
    ON fd.day = dm.day AND fd.state_description = dm.state_description
    GROUP BY fd.day
),
production_data AS (
    SELECT 
        start_time::date AS day,
        COUNT(*) AS total_units_produced
    FROM table_states
    WHERE state = '35'
      AND (start_time::timestamp)::time BETWEEN '07:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
    GROUP BY day
),
operating_time AS (
    SELECT 
        day,
        28800 AS operating_time_seconds
    FROM production_data
),
quality_data AS (
    SELECT 
        production_date::date AS day,
        total_units_produced,
        total_units_produced - ""non conforme parts"" AS good_units_produced
    FROM production_data pd
    JOIN table0 t0 ON pd.day = t0.production_date::date
),
trs_calculation AS (
    SELECT 
        ot.day,
        ((ot.operating_time_seconds - dt.total_downtime) / ot.operating_time_seconds) *
        ((pd.total_units_produced * 1100) / (ot.operating_time_seconds - dt.total_downtime)) *
        (qd.good_units_produced / pd.total_units_produced) AS TRS
    FROM operating_time ot
    JOIN downtime_calculation dt ON ot.day = dt.day
    JOIN production_data pd ON ot.day = pd.day
    JOIN quality_data qd ON ot.day = qd.day
)
SELECT 
    day,
    TRS
FROM trs_calculation
ORDER BY day;"
"give me the states of MR2 when its start and end time overlaps with the start and end time of welding state in tab10, the output should have the welding , start, end, string of all the MR2 states recorded during the duration of this welding ","WITH welding_states AS (
    SELECT 
        start_time AS welding_start, 
        end_time AS welding_end, 
        state_description AS welding_state
    FROM tab10
    WHERE state_description = 'Welding'
),
mr2_states AS (
    SELECT 
        start_time AS mr2_start, 
        end_time AS mr2_end, 
        state AS mr2_state
    FROM table_states
    WHERE table_name = 'MR2'
),
overlapping_states AS (
    SELECT 
        ws.welding_start, 
        ws.welding_end, 
        ws.welding_state, 
        ms.mr2_state
    FROM welding_states ws
    JOIN mr2_states ms
    ON ws.welding_start <= ms.mr2_end 
    AND ws.welding_end >= ms.mr2_start
)
SELECT 
    welding_start, 
    welding_end, 
    welding_state, 
    STRING_AGG(mr2_state, ', ') AS mr2_states_during_welding,
    COUNT(mr2_state) AS mr2_states_count
FROM overlapping_states
GROUP BY 
    welding_start, 
    welding_end, 
    welding_state
ORDER BY 
    welding_start;"
"give me the states of MR2 when its start and end time overlaps with the start and end time of welding state in tab10, the output should have the welding , start, end, string of all the MR2 states recorded during the duration of this welding ","WITH welding_states AS (
    SELECT 
        start_time AS welding_start, 
        end_time AS welding_end, 
        state_description AS welding_state
    FROM tab10
    WHERE state_description = 'Welding'
),
mr2_states AS (
    SELECT 
        start_time AS mr2_start, 
        end_time AS mr2_end, 
        state AS mr2_state
    FROM table_states
    WHERE table_name = 'MR2'
),
overlapping_states AS (
    SELECT 
        ws.welding_start, 
        ws.welding_end, 
        ws.welding_state, 
        ms.mr2_state
    FROM welding_states ws
    JOIN mr2_states ms
    ON ws.welding_start <= ms.mr2_end 
    AND ws.welding_end >= ms.mr2_start
)
SELECT 
    welding_start, 
    welding_end, 
    welding_state, 
    STRING_AGG(mr2_state, ', ') AS mr2_states_during_welding
FROM overlapping_states
GROUP BY 
    welding_start, 
    welding_end, 
    welding_state
ORDER BY 
    welding_start desc;"
how many parts were manifactured in the period 2025-02-01 to 2025-02-11?,"SELECT 
    COUNT(*) AS parts_manufactured
FROM table_states 
WHERE state = '35' 
  AND table_name = 'TAB10' 
  AND (
      (start_time >= '2025-02-01' AND end_time <= '2025-02-11') 
      OR start_time::DATE = '2025-02-20' 
      OR start_time::DATE = '2025-03-16'
  );"
"calculer le trs de chaque jour, utiliser les donnees de qualite","WITH filtered_data AS (
    SELECT 
        start_time::date AS day,
        start_time,
        end_time,
        state_description,
        EXTRACT(EPOCH FROM (end_time - start_time)) AS duration_seconds
    FROM tab10
    WHERE state_description IN ('Loading', 'Processing', 'Waiting', 'Welding', 'Unloading')
      AND (start_time::timestamp)::time BETWEEN '08:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
),
daily_medians AS (
    SELECT 
        day,
        state_description,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration_seconds) AS median_duration_seconds
    FROM filtered_data
    GROUP BY day, state_description
),
downtime_calculation AS (
    SELECT 
        fd.day,
        SUM(CASE 
                WHEN fd.duration_seconds > dm.median_duration_seconds 
                THEN fd.duration_seconds - dm.median_duration_seconds 
                ELSE 0 
            END) - 60600 AS total_downtime
    FROM filtered_data fd
    JOIN daily_medians dm 
    ON fd.day = dm.day AND fd.state_description = dm.state_description
    GROUP BY fd.day
),
production_data AS (
    SELECT 
        start_time::date AS day,
        COUNT(*) AS total_units_produced
    FROM table_states
    WHERE state = '35'
      AND (start_time::timestamp)::time BETWEEN '07:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
    GROUP BY day
),
operating_time AS (
    SELECT 
        day,
        28800 AS operating_time_seconds
    FROM production_data
),
quality_data AS (
    SELECT 
        t0.Date AS day,
        t0.""Non Conform Parts Detected"" AS non_conform_parts,
        pd.total_units_produced
    FROM table0 t0
    JOIN production_data pd ON t0.Date = pd.day
),
trs_calculation AS (
    SELECT 
        ot.day,
        ((ot.operating_time_seconds - dt.total_downtime) / ot.operating_time_seconds) *
        ((pd.total_units_produced * 1100) / (ot.operating_time_seconds - dt.total_downtime)) *
        ((pd.total_units_produced - qd.non_conform_parts) / pd.total_units_produced) AS TRS
    FROM operating_time ot
    JOIN downtime_calculation dt ON ot.day = dt.day
    JOIN production_data pd ON ot.day = pd.day
    JOIN quality_data qd ON ot.day = qd.day
)
SELECT 
    day,
    TRS
FROM trs_calculation
ORDER BY day;"
how many parts where manufactured each day of W10,"WITH production_data AS (
    SELECT 
        end_time::date AS production_date,
        COUNT(*) AS units_produced 
    FROM table_states 
    WHERE state = '35' 
      AND table_name = 'TAB10'
      AND EXTRACT(WEEK FROM end_time) = 10
    GROUP BY end_time::date
)
SELECT * FROM production_data;"
how many parts where manufactured today and last friday and what is the difference between them,"WITH today_parts AS (
    SELECT COUNT(*) AS parts_today
    FROM table_states 
    WHERE state = '35' 
      AND table_name = 'TAB10' 
      AND start_time::DATE = CURRENT_DATE
),
last_friday_parts AS (
    SELECT COUNT(*) AS parts_last_friday
    FROM table_states 
    WHERE state = '35' 
      AND table_name = 'TAB10' 
      AND start_time::DATE = CURRENT_DATE - INTERVAL '1 day' * (EXTRACT(DOW FROM CURRENT_DATE) + 2)
)
SELECT 
    parts_today, 
    parts_last_friday, 
    parts_today - parts_last_friday AS difference
FROM today_parts, last_friday_parts;"
"how many parts where manufactured in total in each table (3,7,10)","WITH parts_tab3 AS (
    SELECT COUNT(*) AS parts_tab3
    FROM table_states 
    WHERE state = '30' 
      AND table_name = 'TAB03'
),
parts_tab7 AS (
    SELECT COUNT(*) AS parts_tab7
    FROM table_states 
    WHERE state = '30' 
      AND table_name = 'TAB07'
),
parts_tab10 AS (
    SELECT COUNT(*) AS parts_tab10
    FROM table_states 
    WHERE state = '35' 
      AND table_name = 'TAB10'
)
SELECT 
    parts_tab3, 
    parts_tab7, 
    parts_tab10, 
    ABS(parts_tab3 - parts_tab7) AS diff_tab3_tab7, 
    ABS(parts_tab3 - parts_tab10) AS diff_tab3_tab10, 
    ABS(parts_tab7 - parts_tab10) AS diff_tab7_tab10
FROM parts_tab3, parts_tab7, parts_tab10;"
how many part where manufatured in table 3,"SELECT COUNT(*) 
FROM table_states 
WHERE state = '30' 
  AND table_name = 'TAB03';"
how many parts where manufactured in table 7,"SELECT COUNT(*) 
FROM table_states 
WHERE state = '30' 
  AND table_name = 'TAB07';"
How many times does state 35 repeat within the period 2025-02-01 to 2025-02-05?,SELECT COUNT(*) FROM table_states WHERE state = 35 AND start_time >= '2025-02-01' AND end_time <= '2025-02-05'
What is the total number of states within the period 2025-03-01 to 2025-03-07?,SELECT COUNT(DISTINCT state) FROM table_states WHERE start_time >= '2025-03-01' AND end_time <= '2025-03-07'
What is the average duration of execution of state 10 between the period 2025-02-01 to 2025-02-05 in hours?,SELECT AVG(EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp)) /60  AS period FROM table_states WHERE start_time >= '2025-02-01' AND end_time <= '2025-02-05' and state = '10';
combien de fois state 35 est repeter dans la period 2025-02-01 et 2025-02-05?,SELECT COUNT(*) FROM table_states WHERE state = '35' AND start_time >= '2025-02-01' AND end_time <= '2025-02-05'
quelle est la duree median de state welding en minutes pour tab10?,"WITH durations AS (SELECT EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 60 AS duration FROM tab10 WHERE state_description = 'Welding')
select PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration) AS median_duration_seconds from durations;"
quelle est la duree moyenne d'execution de state loading en minutes?,SELECT AVG(EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp)) / 60 AS period FROM tab10 WHERE state_description = 'Loading';
quelle est la duree total d'execution de state loading en minutes dans la period 2025-01-29 08:11:00 et 2025-01-29 15:29:00 pour tab07 ?,SELECT SUM(EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp)) / 3600 AS period FROM tab07 WHERE state_description = 'Loading' AND start_time >= '2025-01-29 08:11:00' AND end_time <= '2025-01-29 15:29:00';
donner moi 10 exemples de duree de welding dans tab10?,WITH durations AS (SELECT EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 3600 AS duration FROM tab10 WHERE state_description = 'Welding') SELECT * FROM durations LIMIT 10;
combien de fois state Unloading est repeter dans tab03 dans la period 2025-02-01 et 2025-02-05?,SELECT COUNT(*) FROM tab03 WHERE state_description = 'Unloading' AND start_time >= '2025-02-01' AND end_time <= '2025-02-05'
how many parts were manifactured in the period 2025-02-01 to 2025-02-11?,SELECT count(*) FROM table_states WHERE state = '35' AND table_name = 'TAB10' AND start_time >= '2025-02-01' AND end_time <= '2025-02-11';
how many parts were manifactured during february 2025?,"SELECT count(*) FROM table_states WHERE state = '35' AND table_name = 'TAB10' AND date_part('month',end_time::timestamp) = '02' AND date_part('year',end_time::timestamp) = '2025';"
quelle est la duree median de chaque state dans tab10,"WITH durations AS (SELECT state_description, EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 60 AS duration FROM tab10) select state_description, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration) AS median_duration_seconds from durations GROUP BY state_description;"
quelle est le downtime de chaque state dans tab10 en minutes dans la periode 2025-02-01 et 2025-02-03?,"WITH durations AS (
                    SELECT start_time,state_description, EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 60 AS duration 
                    FROM tab10),
                    median_durations as (select state_description, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration) AS median_duration from durations GROUP BY state_description)
                    ,downtimes AS (
                      SELECT 
                        d.start_time,
                        d.state_description,
                        CASE 
                          WHEN d.duration > m.median_duration THEN d.duration - m.median_duration
                          ELSE 0
                        END AS downtime
                      FROM durations d
                      JOIN median_durations m on
                        d.state_description = m.state_description
                    )
                    select * from downtimes;"
quelle est la duree median de chaque state dans tab10 en minutes?,"WITH durations AS (SELECT state_description, EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 60 AS duration FROM tab10)
SELECT state_description, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration) AS median_duration_minutes FROM durations GROUP BY state_description;"
"give me the downtime of each state then Determine Production Data such that:  Define production as the count of records where state_description is 'Welding'. Count these records for each day, using a slightly broader time window (e.g., from 07:00:00 to 16:00:00), and again, exclude the current day. This gives you the total units produced per day.","WITH durations AS (SELECT start_time,state_description, EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 60 AS duration FROM tab10), median_durations as (select state_description, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration) AS median_duration from durations GROUP BY state_description), downtimes AS (SELECT d.start_time, d.state_description, CASE WHEN d.duration > m.median_duration THEN d.duration - m.median_duration ELSE 0 END AS downtime FROM durations d JOIN median_durations m on d.state_description = m.state_description), production_data AS (SELECT start_time::date AS production_date, COUNT(*) AS units_produced FROM tab10 WHERE state_description = 'Welding' AND (start_time::timestamp)::time >= '07:00:00' AND (start_time::timestamp)::time <= '16:00:00' GROUP BY start_time::Date) SELECT * FROM production_data;"
"what is the median duration of a cycle(from the first state 35 to the next one 35,36,...,35)?","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
)
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY cycle_duration_minutes) AS median_cycle_duration_minutes
FROM cycle_durations;"
"what is the duration of each cycle in minutes(a cycle is from state 35 to the next one 35,36,...,35)","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time,
        start_time::date AS cycle_day
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        cycle_day,
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
)
SELECT cycle_day, cycle_duration_minutes
FROM cycle_durations;"
"give me the the duration of each cycle in minutes, start_time of the cycle and end_time of the cycle(a cycle is from state 35 to the next one 35,36,...,35)","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        start_time AS cycle_start_time,
        next_welding_start_time AS cycle_end_time,
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
)
SELECT cycle_start_time, cycle_end_time, cycle_duration_minutes
FROM cycle_durations;"
"what is the duration of each cycle in minutes(a cycle is from state 35 to the next one 35,36,...,35)","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        start_time AS cycle_start_time,
        next_welding_start_time AS cycle_end_time,
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
)
SELECT cycle_start_time, cycle_end_time, cycle_duration_minutes
FROM cycle_durations;"
"what is the duration of each cycle in minutes(a cycle is from state 35 to the next one 35,36,...,35)","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        start_time AS cycle_start_time,
        next_welding_start_time AS cycle_end_time,
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
)
SELECT 
    cycle_start_time, 
    cycle_end_time, 
    cycle_duration_minutes,
    MAX(cycle_duration_minutes) OVER () AS max_duration,
    MIN(cycle_duration_minutes) OVER () AS min_duration
FROM cycle_durations
WHERE cycle_duration_minutes < 30;"
"i want you to give me the cycles durations, after that i want you to give the percentage of each minutes in the duration so like if we have these duration [10.2,10.3,15.9,13.4] then the percentages will be {10:50%,15:25%, 13:25%}, take only the cycle durations that are below 30, you final answer should contain a column minutes and a column percentage of that minute.","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
),
filtered_cycles AS (
    SELECT 
        ROUND(cycle_duration_minutes) AS minutes
    FROM cycle_durations
    WHERE cycle_duration_minutes < 30
),
minutes_count AS (
    SELECT 
        minutes, 
        COUNT(*) AS count
    FROM filtered_cycles
    GROUP BY minutes
),
total_count AS (
    SELECT 
        SUM(count) AS total
    FROM minutes_count
)
SELECT 
    mc.minutes, 
    ROUND((mc.count::numeric / tc.total) * 100, 2) AS percentage
FROM minutes_count mc, total_count tc
ORDER BY mc.minutes;"
temps  de cycle station 10,"WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35' AND table_name = 'TAB10'
),
cycle_durations AS (
    SELECT 
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
)
SELECT cycle_duration_minutes
FROM cycle_durations;"
HOW MUCH WE HAVE TODAY IN PRODUCTION,SELECT count(*) FROM table_states WHERE state = '35' AND table_name = 'TAB10' AND start_time >= CURRENT_DATE;
give me last 10 days production report,"WITH production_data AS (
    SELECT 
        end_time::date AS production_date,
        COUNT(*) AS units_produced 
    FROM table_states 
    WHERE state = '35' 
    GROUP BY end_time::date
    ORDER BY production_date DESC 
    LIMIT 10
)
SELECT * FROM production_data;"
can calculate the TRS also known as OEE.,"WITH filtered_data AS (
    SELECT 
        start_time::date AS day,
        start_time,
        end_time,
        state_description,
        EXTRACT(EPOCH FROM (end_time - start_time)) AS duration_seconds
    FROM tab10
    WHERE state_description IN ('Loading', 'Processing', 'Waiting', 'Welding', 'Unloading')
      AND (start_time::timestamp)::time BETWEEN '08:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
),
daily_medians AS (
    SELECT 
        day,
        state_description,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration_seconds) AS median_duration_seconds
    FROM filtered_data
    GROUP BY day, state_description
),
downtime_calculation AS (
    SELECT 
        fd.day,
        SUM(CASE 
                WHEN fd.duration_seconds > dm.median_duration_seconds 
                THEN fd.duration_seconds - dm.median_duration_seconds 
                ELSE 0 
            END) - 60600 AS total_downtime
    FROM filtered_data fd
    JOIN daily_medians dm 
    ON fd.day = dm.day AND fd.state_description = dm.state_description
    GROUP BY fd.day
),
production_data AS (
    SELECT 
        start_time::date AS day,
        COUNT(*) AS total_units_produced
    FROM table_states
    WHERE state = '35'
      AND (start_time::timestamp)::time BETWEEN '07:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
    GROUP BY day
),
operating_time AS (
    SELECT 
        day,
        28800 AS operating_time_seconds
    FROM production_data
),
quality_data AS (
    SELECT 
        day,
        total_units_produced AS good_units_produced
    FROM production_data
),
trs_calculation AS (
    SELECT 
        ot.day,
        ((ot.operating_time_seconds - dt.total_downtime) / ot.operating_time_seconds) *
        ((pd.total_units_produced * 1100) / (ot.operating_time_seconds - dt.total_downtime)) *
        (qd.good_units_produced / pd.total_units_produced) AS TRS
    FROM operating_time ot
    JOIN downtime_calculation dt ON ot.day = dt.day
    JOIN production_data pd ON ot.day = pd.day
    JOIN quality_data qd ON ot.day = qd.day
)
SELECT 
    day,
    TRS
FROM trs_calculation
ORDER BY day;"
calculer le trs de chaque jour,"WITH filtered_data AS (
    SELECT 
        start_time::date AS day,
        start_time,
        end_time,
        state_description,
        EXTRACT(EPOCH FROM (end_time - start_time)) AS duration_seconds
    FROM tab10
    WHERE state_description IN ('Loading', 'Processing', 'Waiting', 'Welding', 'Unloading')
      AND (start_time::timestamp)::time BETWEEN '08:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
),
daily_medians AS (
    SELECT 
        day,
        state_description,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration_seconds) AS median_duration_seconds
    FROM filtered_data
    GROUP BY day, state_description
),
downtime_calculation AS (
    SELECT 
        fd.day,
        SUM(CASE 
                WHEN fd.duration_seconds > dm.median_duration_seconds 
                THEN fd.duration_seconds - dm.median_duration_seconds 
                ELSE 0 
            END) - 60600 AS total_downtime
    FROM filtered_data fd
    JOIN daily_medians dm 
    ON fd.day = dm.day AND fd.state_description = dm.state_description
    GROUP BY fd.day
),
production_data AS (
    SELECT 
        start_time::date AS day,
        COUNT(*) AS total_units_produced
    FROM table_states
    WHERE state = '35'
      AND (start_time::timestamp)::time BETWEEN '07:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
    GROUP BY day
),
operating_time AS (
    SELECT 
        day,
        28800 AS operating_time_seconds
    FROM production_data
),
quality_data AS (
    SELECT 
        day,
        total_units_produced AS good_units_produced
    FROM production_data
),
trs_calculation AS (
    SELECT 
        ot.day,
        ((ot.operating_time_seconds - dt.total_downtime) / ot.operating_time_seconds) *
        ((pd.total_units_produced * 1100) / (ot.operating_time_seconds - dt.total_downtime)) *
        (qd.good_units_produced / pd.total_units_produced) AS TRS
    FROM operating_time ot
    JOIN downtime_calculation dt ON ot.day = dt.day
    JOIN production_data pd ON ot.day = pd.day
    JOIN quality_data qd ON ot.day = qd.day
)
SELECT 
    day,
    TRS
FROM trs_calculation
ORDER BY day;"
calculer le trs de chaque jour,"WITH filtered_data AS (
    SELECT 
        start_time::date AS day,
        start_time,
        end_time,
        state_description,
        EXTRACT(EPOCH FROM (end_time - start_time)) AS duration_seconds
    FROM tab10
    WHERE state_description IN ('Loading', 'Processing', 'Waiting', 'Welding', 'Unloading')
      AND (start_time::timestamp)::time BETWEEN '08:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
),
daily_medians AS (
    SELECT 
        day,
        state_description,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration_seconds) AS median_duration_seconds
    FROM filtered_data
    GROUP BY day, state_description
),
downtime_calculation AS (
    SELECT 
        fd.day,
        SUM(CASE 
                WHEN fd.duration_seconds > dm.median_duration_seconds 
                THEN fd.duration_seconds - dm.median_duration_seconds 
                ELSE 0 
            END) - 60600 AS total_downtime
    FROM filtered_data fd
    JOIN daily_medians dm 
    ON fd.day = dm.day AND fd.state_description = dm.state_description
    GROUP BY fd.day
),
production_data AS (
    SELECT 
        start_time::date AS day,
        COUNT(*) AS total_units_produced
    FROM table_states
    WHERE state = '35'
      AND (start_time::timestamp)::time BETWEEN '07:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
    GROUP BY day
),
operating_time AS (
    SELECT 
        day,
        28800 AS operating_time_seconds
    FROM production_data
),
quality_data AS (
    SELECT 
        day,
        total_units_produced AS good_units_produced
    FROM production_data
),
trs_calculation AS (
    SELECT 
        ot.day,
        ((ot.operating_time_seconds - dt.total_downtime) / ot.operating_time_seconds) AS availability,
        ((pd.total_units_produced * 1100) / (ot.operating_time_seconds - dt.total_downtime)) AS productivity,
        (qd.good_units_produced / pd.total_units_produced) AS quality,
        ((ot.operating_time_seconds - dt.total_downtime) / ot.operating_time_seconds) *
        ((pd.total_units_produced * 1100) / (ot.operating_time_seconds - dt.total_downtime)) *
        (qd.good_units_produced / pd.total_units_produced) AS TRS
    FROM operating_time ot
    JOIN downtime_calculation dt ON ot.day = dt.day
    JOIN production_data pd ON ot.day = pd.day
    JOIN quality_data qd ON ot.day = qd.day
)
SELECT 
    day,
    TRS,
    availability,
    productivity,
    quality
FROM trs_calculation
ORDER BY day;"
use table states to plot how the state changes in terms of start_time,"SELECT start_time, state
FROM table_states
ORDER BY start_time;"
how many parts where manufactured today?,"SELECT COUNT(*) 
FROM table_states 
WHERE state = '35' 
  AND table_name = 'TAB10' 
  AND start_time::DATE = CURRENT_DATE;"
What are the top 5 most frequent errors and the top 5 state descriptions in which these errors occur in tab10?,"WITH frequent_errors AS (
    SELECT 
        err, 
        COUNT(*) AS error_count
    FROM errors
    GROUP BY err
    ORDER BY error_count DESC
    LIMIT 5
),
error_state_descriptions AS (
    SELECT 
        e.err, 
        t.state_description, 
        COUNT(*) AS state_count
    FROM errors e
    JOIN tab10 t ON e.start_time BETWEEN t.start_time AND t.end_time
    WHERE e.err IN (SELECT err FROM frequent_errors)
    GROUP BY e.err, t.state_description
    ORDER BY state_count DESC
)
SELECT 
    err, 
    state_description, 
    state_count
FROM error_state_descriptions
ORDER BY state_count DESC
LIMIT 5;"
what are the top 5 errors that the most duration,"SELECT 
    err, 
    SUM(EXTRACT(EPOCH FROM (end_time - start_time)) / 60) AS total_duration_minutes
FROM errors
GROUP BY err
ORDER BY total_duration_minutes DESC
LIMIT 5;"
"For each state in the tab10 table, what is the average duration of errors that occurred during that state period?","WITH error_durations AS (
    SELECT 
        t.state_description, 
        EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 60 AS error_duration_minutes
    FROM errors e
    JOIN tab10 t 
    ON e.start_time BETWEEN t.start_time AND t.end_time
)
SELECT 
    state_description, 
    AVG(error_duration_minutes) AS avg_error_duration_minutes
FROM error_durations
GROUP BY state_description;"
Which state periods in the tab10 table do not have any associated error records (i.e. no error’s start_time falls within the state’s time interval)?,"SELECT t.start_time, t.end_time, t.state_description
FROM tab10 t
LEFT JOIN errors e ON e.start_time BETWEEN t.start_time AND t.end_time
WHERE e.id IS NULL;"
Which state periods in the tab10 table do not have any associated error records (i.e. no error’s start_time falls within the state’s time interval)?,"SELECT *
FROM tab10
WHERE start_time > (SELECT MIN(start_time) FROM errors)
AND NOT EXISTS (
    SELECT 1
    FROM errors
    WHERE errors.start_time BETWEEN tab10.start_time AND tab10.end_time
);"
Identify any errors from the errors table whose time intervals overlap with more than one state period in the tab10 table.,"SELECT e.*
FROM errors e
JOIN tab10 t1 ON e.start_time BETWEEN t1.start_time AND t1.end_time
JOIN tab10 t2 ON e.end_time BETWEEN t2.start_time AND t2.end_time
WHERE t1.id <> t2.id;"
What are the distinct error types from the errors table whose time intervals overlap with more than one state period in the tab10 table?,"WITH overlapping_errors AS (
    SELECT DISTINCT e.err
    FROM errors e
    JOIN tab10 t1 ON e.start_time BETWEEN t1.start_time AND t1.end_time
    JOIN tab10 t2 ON e.end_time BETWEEN t2.start_time AND t2.end_time
    WHERE t1.id <> t2.id
)
SELECT err
FROM overlapping_errors;"
"For each state in the tab10 table, what are the distinct error types that occurred during that state’s time interval?","SELECT DISTINCT 
    t.state_description, 
    e.err
FROM tab10 t
JOIN errors e ON e.start_time BETWEEN t.start_time AND t.end_time
ORDER BY t.state_description, e.err;"
What are the distinct error types from the errors table whose time intervals overlap with more than one state period in the tab10 table?,"WITH overlapping_errors AS (
    SELECT DISTINCT 
        e.err, 
        t1.state_description AS state1, 
        t2.state_description AS state2
    FROM errors e
    JOIN tab10 t1 ON e.start_time BETWEEN t1.start_time AND t1.end_time
    JOIN tab10 t2 ON e.end_time BETWEEN t2.start_time AND t2.end_time
    WHERE t1.id <> t2.id
)
SELECT 
    err, 
    state1, 
    state2
FROM overlapping_errors;"
What are the distinct error types from the errors table whose time intervals overlap with more than one state period in the tab10 table?,"WITH overlapping_errors AS (
    SELECT 
        e.err, 
        t1.state_description AS state1, 
        t2.state_description AS state2, 
        t3.state_description AS state3
    FROM errors e
    JOIN tab10 t1 ON e.start_time BETWEEN t1.start_time AND t1.end_time
    JOIN tab10 t2 ON e.end_time BETWEEN t2.start_time AND t2.end_time
    LEFT JOIN tab10 t3 ON e.start_time BETWEEN t3.start_time AND t3.end_time AND t3.id NOT IN (t1.id, t2.id)
    WHERE t1.id <> t2.id
)
SELECT DISTINCT 
    err, 
    state1, 
    state2, 
    state3
FROM overlapping_errors
WHERE state3 IS NOT NULL
UNION
SELECT DISTINCT 
    err, 
    state1, 
    state2, 
    NULL AS state3
FROM overlapping_errors
WHERE state3 IS NULL;"
What are the distinct error types from the errors table whose time intervals overlap with more than one state period?,"WITH overlapping_errors AS (
    SELECT DISTINCT e.err
    FROM table0 e
    JOIN table1 t1 ON e.start_time BETWEEN t1.start_time AND t1.end_time
    JOIN table1 t2 ON e.end_time BETWEEN t2.start_time AND t2.end_time
    WHERE t1.id <> t2.id
)
SELECT err
FROM overlapping_errors;"
