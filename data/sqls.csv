,id,question,content,training_data_type
0,fccc05d6-0d65-5a24-873f-9432b98bf4aa-sql,How many times does state 35 repeat within the period 2025-02-01 to 2025-02-05?,SELECT COUNT(*) FROM table_states WHERE state = 35 AND start_time >= '2025-02-01' AND end_time <= '2025-02-05',sql
1,8784882c-28de-5a29-8c48-3e610ae7409f-sql,What is the total number of states within the period 2025-03-01 to 2025-03-07?,SELECT COUNT(DISTINCT state) FROM table_states WHERE start_time >= '2025-03-01' AND end_time <= '2025-03-07',sql
2,d30f565a-2bda-5bfc-a391-19c1dd598993-sql,What is the average duration of execution of state 10 between the period 2025-02-01 to 2025-02-05 in hours?,SELECT AVG(EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp)) /60  AS period FROM table_states WHERE start_time >= '2025-02-01' AND end_time <= '2025-02-05' and state = '10';,sql
3,477fa1c1-3255-53ec-9395-043123699baa-sql,combien de fois state 35 est repeter dans la period 2025-02-01 et 2025-02-05?,SELECT COUNT(*) FROM table_states WHERE state = '35' AND start_time >= '2025-02-01' AND end_time <= '2025-02-05',sql
4,39d5e71d-1f4a-5106-abde-91c5d2ef1dba-sql,quelle est la duree median de state welding en minutes pour tab10?,"WITH durations AS (SELECT EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 60 AS duration FROM tab10 WHERE state_description = 'Welding')
select PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration) AS median_duration_seconds from durations;",sql
5,05d41b15-ebd4-5d60-8bff-75bdb4b1bec8-sql,quelle est la duree moyenne d'execution de state loading en minutes?,SELECT AVG(EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp)) / 60 AS period FROM tab10 WHERE state_description = 'Loading';,sql
6,faa4e7d2-b057-57a3-b909-d1c9ce77d688-sql,quelle est la duree total d'execution de state loading en minutes dans la period 2025-01-29 08:11:00 et 2025-01-29 15:29:00 pour tab07 ?,SELECT SUM(EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp)) / 3600 AS period FROM tab07 WHERE state_description = 'Loading' AND start_time >= '2025-01-29 08:11:00' AND end_time <= '2025-01-29 15:29:00';,sql
7,718df7b1-714a-565f-8189-cdd8c8f004c7-sql,donner moi 10 exemples de duree de welding dans tab10?,WITH durations AS (SELECT EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 3600 AS duration FROM tab10 WHERE state_description = 'Welding') SELECT * FROM durations LIMIT 10;,sql
8,50ef9a7a-9742-5110-861e-16ebc9532536-sql,combien de fois state Unloading est repeter dans tab03 dans la period 2025-02-01 et 2025-02-05?,SELECT COUNT(*) FROM tab03 WHERE state_description = 'Unloading' AND start_time >= '2025-02-01' AND end_time <= '2025-02-05',sql
9,25af7741-c41b-55fd-8d0c-06e5a577a487-sql,how many parts were manifactured in the period 2025-02-01 to 2025-02-11?,SELECT count(*) FROM table_states WHERE state = '35' AND table_name = 'TAB10' AND start_time >= '2025-02-01' AND end_time <= '2025-02-11';,sql
10,338d9c2d-dc7e-5a44-8d75-dcd604919e52-sql,how many parts were manifactured during february 2025?,"SELECT count(*) FROM table_states WHERE state = '35' AND table_name = 'TAB10' AND to_char(end_time::timestamp, 'MM') = '02' AND to_char(end_time::timestamp, 'YYYY') = '2025';",sql
11,19fc29c7-6dfd-5da6-8a37-a15b6e1e178f-sql,quelle est la duree median de chaque state dans tab10,"WITH durations AS (SELECT state_description, EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 60 AS duration FROM tab10) select state_description, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration) AS median_duration_seconds from durations GROUP BY state_description;",sql
12,03b264c0-ba5c-5ebe-8e75-702e4d824ef5-sql,quelle est le downtime de chaque state dans tab10 en minutes dans la periode 2025-02-01 et 2025-02-03?,"WITH durations AS (
                    SELECT start_time,state_description, EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 60 AS duration 
                    FROM tab10),
                    median_durations as (select state_description, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration) AS median_duration from durations GROUP BY state_description)
                    ,downtimes AS (
                      SELECT 
                        d.start_time,
                        d.state_description,
                        CASE 
                          WHEN d.duration > m.median_duration THEN d.duration - m.median_duration
                          ELSE 0
                        END AS downtime
                      FROM durations d
                      JOIN median_durations m on
                        d.state_description = m.state_description
                    )
                    select * from downtimes;",sql
13,13048b05-1326-5184-b599-6dc89228fde5-sql,quelle est la duree median de chaque state dans tab10 en minutes?,"WITH durations AS (SELECT state_description, EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 60 AS duration FROM tab10)
SELECT state_description, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration) AS median_duration_minutes FROM durations GROUP BY state_description;",sql
14,34e95080-5439-5b87-9ab9-149e4d002faf-sql,"give me the downtime of each state then Determine Production Data such that:  Define production as the count of records where state_description is 'Welding'. Count these records for each day, using a slightly broader time window (e.g., from 07:00:00 to 16:00:00), and again, exclude the current day. This gives you the total units produced per day.","WITH durations AS (SELECT start_time,state_description, EXTRACT(EPOCH FROM end_time::timestamp - start_time::timestamp) / 60 AS duration FROM tab10), median_durations as (select state_description, PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration) AS median_duration from durations GROUP BY state_description), downtimes AS (SELECT d.start_time, d.state_description, CASE WHEN d.duration > m.median_duration THEN d.duration - m.median_duration ELSE 0 END AS downtime FROM durations d JOIN median_durations m on d.state_description = m.state_description), production_data AS (SELECT DATE(start_time) AS production_date, COUNT(*) AS units_produced FROM tab10 WHERE state_description = 'Welding' AND start_time::time >= '07:00:00' AND end_time::time <= '16:00:00' GROUP BY DATE(start_time)) SELECT * FROM production_data;",sql
15,7e6ae14d-a322-577d-8b27-40ff49f0626f-sql,"what is the median duration of a cycle(from the first state 35 to the next one 35,36,...,35)?","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
)
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY cycle_duration_minutes) AS median_cycle_duration_minutes
FROM cycle_durations;",sql
16,c7aab3a9-9ed5-5c87-9808-f18446aac60b-sql,"what is the duration of each cycle in minutes(a cycle is from state 35 to the next one 35,36,...,35)","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time,
        DATE(start_time) AS cycle_day
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        cycle_day,
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
)
SELECT cycle_day, cycle_duration_minutes
FROM cycle_durations;",sql
17,0a4081ed-3a2e-5c00-b4f9-66cdd03237ec-sql,"give me the the duration of each cycle in minutes, start_time of the cycle and end_time of the cycle(a cycle is from state 35 to the next one 35,36,...,35)","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        start_time AS cycle_start_time,
        next_welding_start_time AS cycle_end_time,
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
)
SELECT cycle_start_time, cycle_end_time, cycle_duration_minutes
FROM cycle_durations;",sql
18,c85b9819-6726-5b35-bac2-ff02219512bf-sql,"what is the duration of each cycle in minutes(a cycle is from state 35 to the next one 35,36,...,35)","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        start_time AS cycle_start_time,
        next_welding_start_time AS cycle_end_time,
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
)
SELECT cycle_start_time, cycle_end_time, cycle_duration_minutes
FROM cycle_durations;",sql
19,2a1137c2-49ba-567d-9663-a2bab8941bc6-sql,"what is the duration of each cycle in minutes(a cycle is from state 35 to the next one 35,36,...,35)","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        start_time AS cycle_start_time,
        next_welding_start_time AS cycle_end_time,
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
)
SELECT 
    cycle_start_time, 
    cycle_end_time, 
    cycle_duration_minutes,
    MAX(cycle_duration_minutes) OVER () AS max_duration,
    MIN(cycle_duration_minutes) OVER () AS min_duration
FROM cycle_durations
WHERE cycle_duration_minutes < 30;",sql
20,6f36d348-4cde-508b-b35b-0de616526cde-sql,"i want you to give me the cycles durations, after that i want you to give the percentage of each minutes in the duration so like if we have these duration [10.2,10.3,15.9,13.4] then the percentages will be {10:50%,15:25%, 13:25%}, take only the cycle durations that are below 30, you final answer should contain a column minutes and a column percentage of that minute.","WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35'
),
cycle_durations AS (
    SELECT 
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
),
filtered_cycles AS (
    SELECT 
        ROUND(cycle_duration_minutes) AS minutes
    FROM cycle_durations
    WHERE cycle_duration_minutes < 30
),
minutes_count AS (
    SELECT 
        minutes, 
        COUNT(*) AS count
    FROM filtered_cycles
    GROUP BY minutes
),
total_count AS (
    SELECT 
        SUM(count) AS total
    FROM minutes_count
)
SELECT 
    mc.minutes, 
    ROUND((mc.count::numeric / tc.total) * 100, 2) AS percentage
FROM minutes_count mc, total_count tc
ORDER BY mc.minutes;",sql
21,f1ff8909-f233-5931-ba05-3e51c57a89e4-sql,temps  de cycle station 10,"WITH welding_states AS (
    SELECT 
        id, 
        start_time, 
        end_time, 
        LEAD(start_time) OVER (ORDER BY start_time) AS next_welding_start_time
    FROM table_states
    WHERE state = '35' AND table_name = 'TAB10'
),
cycle_durations AS (
    SELECT 
        EXTRACT(EPOCH FROM next_welding_start_time - end_time) / 60 AS cycle_duration_minutes
    FROM welding_states
    WHERE next_welding_start_time IS NOT NULL
)
SELECT cycle_duration_minutes
FROM cycle_durations;",sql
22,66c42d80-0af1-5e5b-93bb-91980437a3c5-sql,HOW MUCH WE HAVE TODAY IN PRODUCTION,SELECT count(*) FROM table_states WHERE state = '35' AND table_name = 'TAB10' AND start_time >= CURRENT_DATE;,sql
23,79d2994b-8461-5d36-9428-caddb6064c04-sql,give me last 10 days production report,"WITH production_data AS (
    SELECT 
        DATE(end_time) AS production_date, 
        COUNT(*) AS units_produced 
    FROM table_states 
    WHERE state = '35' 
    GROUP BY DATE(end_time) 
    ORDER BY production_date DESC 
    LIMIT 10
)
SELECT * FROM production_data;",sql
24,ddf92249-450d-5bcb-8937-0de740f0a1fe-sql,"can calculate the TRS also known as OEE. Please follow these steps to calculate the TRS: Filter the Data: Only include records where state_description is one of ('Loading', 'Processing', 'Waiting', 'Welding', 'Unloading'). Consider only records where the start_time falls between 08:00:00 and 16:00:00. Exclude records from the current day. Calculate Duration per Record: Compute the duration (in seconds) for each record using the difference between end_time and start_time. Use SQLite’s date/time functions, e.g.: scss Copy Edit (julianday(end_time) - julianday(start_time)) * 86400 AS duration_seconds Compute Median Duration per Day and State: For each day (extracted from start_time) and for each state_description, calculate the median of the duration_seconds. (Since SQLite does not have a built-in median function, you can use a correlated subquery with an OFFSET based on the count of records.) Calculate Downtime: For each record, if its duration_seconds is greater than the median duration for that day and state, calculate the “excess” duration as: ini Copy Edit downtime = duration_seconds - median_duration Otherwise, consider downtime as zero. Sum the downtime for each day. Then subtract a fixed value of 60600 seconds from this daily sum to get the total downtime for the day. Determine Production Data: Define production as the count of records where state is '35'. Count these records for each day, using a slightly broader time window (e.g., from 07:00:00 to 16:00:00), and again, exclude the current day. This gives you the total units produced per day. Assume Quality Data: For this calculation, assume all produced units are good (i.e., good units = total units produced). Set Operating Time: Use a fixed operating time of 8 hours per day (which equals 28,800 seconds). Calculate TRS (OEE): Combine the above data in this formula: mathematica Copy Edit TRS = ((Operating Time - Total Downtime) / Operating Time) * ((Total Units Produced * 1100) / (Operating Time - Total Downtime)) * (Good Units Produced / Total Units Produced) Calculate this TRS value for each day. Output: Finally, output the daily TRS values, ordered by day.","WITH filtered_data AS (
    SELECT 
        start_time::date AS day,
        start_time,
        end_time,
        state_description,
        EXTRACT(EPOCH FROM (end_time - start_time)) AS duration_seconds
    FROM tab10
    WHERE state_description IN ('Loading', 'Processing', 'Waiting', 'Welding', 'Unloading')
      AND start_time::time BETWEEN '08:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
),
daily_medians AS (
    SELECT 
        day,
        state_description,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration_seconds) AS median_duration_seconds
    FROM filtered_data
    GROUP BY day, state_description
),
downtime_calculation AS (
    SELECT 
        fd.day,
        SUM(CASE 
                WHEN fd.duration_seconds > dm.median_duration_seconds 
                THEN fd.duration_seconds - dm.median_duration_seconds 
                ELSE 0 
            END) - 60600 AS total_downtime
    FROM filtered_data fd
    JOIN daily_medians dm 
    ON fd.day = dm.day AND fd.state_description = dm.state_description
    GROUP BY fd.day
),
production_data AS (
    SELECT 
        start_time::date AS day,
        COUNT(*) AS total_units_produced
    FROM table_states
    WHERE state = '35'
      AND start_time::time BETWEEN '07:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
    GROUP BY day
),
operating_time AS (
    SELECT 
        day,
        28800 AS operating_time_seconds
    FROM production_data
),
quality_data AS (
    SELECT 
        day,
        total_units_produced AS good_units_produced
    FROM production_data
),
trs_calculation AS (
    SELECT 
        ot.day,
        ((ot.operating_time_seconds - dt.total_downtime) / ot.operating_time_seconds) *
        ((pd.total_units_produced * 1100) / (ot.operating_time_seconds - dt.total_downtime)) *
        (qd.good_units_produced / pd.total_units_produced) AS TRS
    FROM operating_time ot
    JOIN downtime_calculation dt ON ot.day = dt.day
    JOIN production_data pd ON ot.day = pd.day
    JOIN quality_data qd ON ot.day = qd.day
)
SELECT 
    day,
    TRS
FROM trs_calculation
ORDER BY day;",sql
25,b67a468d-4757-583d-bbd7-69131cc67dd3-sql,calculer le trs de chaque jour,"WITH filtered_data AS (
    SELECT 
        start_time::date AS day,
        start_time,
        end_time,
        state_description,
        EXTRACT(EPOCH FROM (end_time - start_time)) AS duration_seconds
    FROM tab10
    WHERE state_description IN ('Loading', 'Processing', 'Waiting', 'Welding', 'Unloading')
      AND start_time::time BETWEEN '08:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
),
daily_medians AS (
    SELECT 
        day,
        state_description,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration_seconds) AS median_duration_seconds
    FROM filtered_data
    GROUP BY day, state_description
),
downtime_calculation AS (
    SELECT 
        fd.day,
        SUM(CASE 
                WHEN fd.duration_seconds > dm.median_duration_seconds 
                THEN fd.duration_seconds - dm.median_duration_seconds 
                ELSE 0 
            END) - 60600 AS total_downtime
    FROM filtered_data fd
    JOIN daily_medians dm 
    ON fd.day = dm.day AND fd.state_description = dm.state_description
    GROUP BY fd.day
),
production_data AS (
    SELECT 
        start_time::date AS day,
        COUNT(*) AS total_units_produced
    FROM table_states
    WHERE state = '35'
      AND start_time::time BETWEEN '07:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
    GROUP BY day
),
operating_time AS (
    SELECT 
        day,
        28800 AS operating_time_seconds
    FROM production_data
),
quality_data AS (
    SELECT 
        day,
        total_units_produced AS good_units_produced
    FROM production_data
),
trs_calculation AS (
    SELECT 
        ot.day,
        ((ot.operating_time_seconds - dt.total_downtime) / ot.operating_time_seconds) *
        ((pd.total_units_produced * 1100) / (ot.operating_time_seconds - dt.total_downtime)) *
        (qd.good_units_produced / pd.total_units_produced) AS TRS
    FROM operating_time ot
    JOIN downtime_calculation dt ON ot.day = dt.day
    JOIN production_data pd ON ot.day = pd.day
    JOIN quality_data qd ON ot.day = qd.day
)
SELECT 
    day,
    TRS
FROM trs_calculation
ORDER BY day;",sql
26,d76fe983-97cf-5740-92f2-837b191f3f65-sql,calculer le trs de chaque jour,"WITH filtered_data AS (
    SELECT 
        start_time::date AS day,
        start_time,
        end_time,
        state_description,
        EXTRACT(EPOCH FROM (end_time - start_time)) AS duration_seconds
    FROM tab10
    WHERE state_description IN ('Loading', 'Processing', 'Waiting', 'Welding', 'Unloading')
      AND start_time::time BETWEEN '08:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
),
daily_medians AS (
    SELECT 
        day,
        state_description,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY duration_seconds) AS median_duration_seconds
    FROM filtered_data
    GROUP BY day, state_description
),
downtime_calculation AS (
    SELECT 
        fd.day,
        SUM(CASE 
                WHEN fd.duration_seconds > dm.median_duration_seconds 
                THEN fd.duration_seconds - dm.median_duration_seconds 
                ELSE 0 
            END) - 60600 AS total_downtime
    FROM filtered_data fd
    JOIN daily_medians dm 
    ON fd.day = dm.day AND fd.state_description = dm.state_description
    GROUP BY fd.day
),
production_data AS (
    SELECT 
        start_time::date AS day,
        COUNT(*) AS total_units_produced
    FROM table_states
    WHERE state = '35'
      AND start_time::time BETWEEN '07:00:00' AND '16:00:00'
      AND start_time::date < CURRENT_DATE
    GROUP BY day
),
operating_time AS (
    SELECT 
        day,
        28800 AS operating_time_seconds
    FROM production_data
),
quality_data AS (
    SELECT 
        day,
        total_units_produced AS good_units_produced
    FROM production_data
),
trs_calculation AS (
    SELECT 
        ot.day,
        ((ot.operating_time_seconds - dt.total_downtime) / ot.operating_time_seconds) AS availability,
        ((pd.total_units_produced * 1100) / (ot.operating_time_seconds - dt.total_downtime)) AS productivity,
        (qd.good_units_produced / pd.total_units_produced) AS quality,
        ((ot.operating_time_seconds - dt.total_downtime) / ot.operating_time_seconds) *
        ((pd.total_units_produced * 1100) / (ot.operating_time_seconds - dt.total_downtime)) *
        (qd.good_units_produced / pd.total_units_produced) AS TRS
    FROM operating_time ot
    JOIN downtime_calculation dt ON ot.day = dt.day
    JOIN production_data pd ON ot.day = pd.day
    JOIN quality_data qd ON ot.day = qd.day
)
SELECT 
    day,
    TRS,
    availability,
    productivity,
    quality
FROM trs_calculation
ORDER BY day;",sql
27,5cfa8dde-dd15-59f4-af0b-3727ecfab4ab-sql,use table states to plot how the state changes in terms of start_time,"SELECT start_time, state
FROM table_states
ORDER BY start_time;",sql
28,f2dbd8b9-2f92-56f7-b7b1-fc49f0386a38-sql,how many parts where manufactured today?,"SELECT COUNT(*) 
FROM table_states 
WHERE state = '35' 
  AND table_name = 'TAB10' 
  AND DATE(start_time) = CURRENT_DATE;",sql
29,73bf2cdd-25c7-5159-b738-d5cb9745451e-sql,What are the top 5 most frequent errors and the top 5 state descriptions in which these errors occur in tab10?,"WITH frequent_errors AS (
    SELECT 
        err, 
        COUNT(*) AS error_count
    FROM errors
    GROUP BY err
    ORDER BY error_count DESC
    LIMIT 5
),
error_state_descriptions AS (
    SELECT 
        e.err, 
        t.state_description, 
        COUNT(*) AS state_count
    FROM errors e
    JOIN tab10 t ON e.start_time BETWEEN t.start_time AND t.end_time
    WHERE e.err IN (SELECT err FROM frequent_errors)
    GROUP BY e.err, t.state_description
    ORDER BY state_count DESC
)
SELECT 
    err, 
    state_description, 
    state_count
FROM error_state_descriptions
ORDER BY state_count DESC
LIMIT 5;",sql
30,71ed57f4-3f1c-5fcd-b878-45060da17d21-sql,what are the top 5 errors that the most duration,"SELECT 
    err, 
    SUM(EXTRACT(EPOCH FROM (end_time - start_time)) / 60) AS total_duration_minutes
FROM errors
GROUP BY err
ORDER BY total_duration_minutes DESC
LIMIT 5;",sql
31,c4916095-c632-58df-93c7-501b5c7258b0-sql,"For each state in the tab10 table, what is the average duration of errors that occurred during that state period?","WITH error_durations AS (
    SELECT 
        t.state_description, 
        EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 60 AS error_duration_minutes
    FROM errors e
    JOIN tab10 t 
    ON e.start_time BETWEEN t.start_time AND t.end_time
)
SELECT 
    state_description, 
    AVG(error_duration_minutes) AS avg_error_duration_minutes
FROM error_durations
GROUP BY state_description;",sql
32,9ea9bb67-6753-511b-87b7-76848b120c32-sql,Which state periods in the tab10 table do not have any associated error records (i.e. no error’s start_time falls within the state’s time interval)?,"SELECT t.start_time, t.end_time, t.state_description
FROM tab10 t
LEFT JOIN errors e ON e.start_time BETWEEN t.start_time AND t.end_time
WHERE e.id IS NULL;",sql
33,619c9160-534b-5a93-b860-00a038dc7645-sql,Which state periods in the tab10 table do not have any associated error records (i.e. no error’s start_time falls within the state’s time interval)?,"SELECT *
FROM tab10
WHERE start_time > (SELECT MIN(start_time) FROM errors)
AND NOT EXISTS (
    SELECT 1
    FROM errors
    WHERE errors.start_time BETWEEN tab10.start_time AND tab10.end_time
);",sql
34,eb50799f-6dcb-57a9-b63a-c11afb6e237a-sql,Identify any errors from the errors table whose time intervals overlap with more than one state period in the tab10 table.,"SELECT e.*
FROM errors e
JOIN tab10 t1 ON e.start_time BETWEEN t1.start_time AND t1.end_time
JOIN tab10 t2 ON e.end_time BETWEEN t2.start_time AND t2.end_time
WHERE t1.id <> t2.id;",sql
35,08ae7b61-908d-5f89-928b-e3632221bfaa-sql,What are the distinct error types from the errors table whose time intervals overlap with more than one state period in the tab10 table?,"WITH overlapping_errors AS (
    SELECT DISTINCT e.err
    FROM errors e
    JOIN tab10 t1 ON e.start_time BETWEEN t1.start_time AND t1.end_time
    JOIN tab10 t2 ON e.end_time BETWEEN t2.start_time AND t2.end_time
    WHERE t1.id <> t2.id
)
SELECT err
FROM overlapping_errors;",sql
36,b5066cfa-2756-504a-ae30-30c390c64f7a-sql,"For each state in the tab10 table, what are the distinct error types that occurred during that state’s time interval?","SELECT DISTINCT 
    t.state_description, 
    e.err
FROM tab10 t
JOIN errors e ON e.start_time BETWEEN t.start_time AND t.end_time
ORDER BY t.state_description, e.err;",sql
37,b9e32f83-cd44-53dd-a6ef-1b51377e3ba8-sql,What are the distinct error types from the errors table whose time intervals overlap with more than one state period in the tab10 table?,"WITH overlapping_errors AS (
    SELECT DISTINCT 
        e.err, 
        t1.state_description AS state1, 
        t2.state_description AS state2
    FROM errors e
    JOIN tab10 t1 ON e.start_time BETWEEN t1.start_time AND t1.end_time
    JOIN tab10 t2 ON e.end_time BETWEEN t2.start_time AND t2.end_time
    WHERE t1.id <> t2.id
)
SELECT 
    err, 
    state1, 
    state2
FROM overlapping_errors;",sql
38,08502b34-f0a6-5848-a2b5-e97f57300c00-sql,What are the distinct error types from the errors table whose time intervals overlap with more than one state period in the tab10 table?,"WITH overlapping_errors AS (
    SELECT 
        e.err, 
        t1.state_description AS state1, 
        t2.state_description AS state2, 
        t3.state_description AS state3
    FROM errors e
    JOIN tab10 t1 ON e.start_time BETWEEN t1.start_time AND t1.end_time
    JOIN tab10 t2 ON e.end_time BETWEEN t2.start_time AND t2.end_time
    LEFT JOIN tab10 t3 ON e.start_time BETWEEN t3.start_time AND t3.end_time AND t3.id NOT IN (t1.id, t2.id)
    WHERE t1.id <> t2.id
)
SELECT DISTINCT 
    err, 
    state1, 
    state2, 
    state3
FROM overlapping_errors
WHERE state3 IS NOT NULL
UNION
SELECT DISTINCT 
    err, 
    state1, 
    state2, 
    NULL AS state3
FROM overlapping_errors
WHERE state3 IS NULL;",sql
